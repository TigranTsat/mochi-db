syntax = "proto3";
package edu.stanford.cs244b.mochi.server.messages;


option optimize_for = SPEED;

enum OperationAction {
    READ = 0;
    DELETE = 1;
    WRITE = 2;
}


/* Operation is the method which is applied to a datastore.
Some examples (in form - {ACTION, OP1, OP2,...}) :
    { READ, "KEY" } -> read value for key "KEY"
    { DELETE, "KEY" } -> delete key "KEY"
    { WRITE, "KEY", "VALUE" } -> write value "VALUE" to key "KEY"
    { WRITE_IF_EQUALS, "KEY", "VALUE", "VALUE_TO_CHECK" } -> writes value "VALUE" to key "KEY" if existing value matches "VALUE_TO_CHECK"

*/
message Operation {
    OperationAction action = 1;
    string operand1 = 2;
    string operand2 = 3;
    string operand3 = 4;
}

message Transaction {
    repeated .edu.stanford.cs244b.mochi.server.messages.Operation operations = 1;
}


/*
Read request hREAD, cid, oid, op, nonceiµcr
. The
replica does an upcall to the server code, passing it the
op. When this call returns it sends the result to the
client in a message hREAD-ANS, result, nonce, currentC,
ridiµcr
. The nonce is used to ensure that the answer is
not a replay.
*/
message ReadToServer {
    string clientId = 1; // cid
    Transaction transaction = 2; // contains (oid and op)
    string nonce = 3;
}

message HelloToServer {
    string msg = 1;
}

message HelloToServer2 {
    string msg = 1;
}

message HelloFromServer {
    string msg = 1;
    string clientMsg = 2;
}

message HelloFromServer2 {
    string msg = 1;
    string clientMsg = 2;
}

message ProtocolMessage {
    oneof payload {
        HelloToServer helloToServer = 101;
        HelloFromServer helloFromServer = 102;
        HelloToServer2 helloToServer2 = 103;
        HelloFromServer2 helloFromServer2 = 104;
        ReadToServer readToServer = 105;
    };
    int64 msgTimestamp = 5;
    string serverId = 6;
    string msgId = 7;
    string replyToMsgId = 8;
}